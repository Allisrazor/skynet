
	//float a[6] = { 3., 1., 2.,
	//	          0., -1., 4. }; // 2 x 4 matrix
	//float x[6] = { -1., 1.,
	//	            2., 0.,
	//                0., 3.};
	//float y[4] = { 0., 0.,
	//	           0., 0. };

	//	cblas_sgemv(CBLAS_ORDER::CblasRowMajor, CBLAS_TRANSPOSE::CblasNoTrans, 3, 3,
	//			1.0, a, 3, x, 1, 0.0, y, 1);

	//cblas_sgemm(CBLAS_ORDER::CblasRowMajor,
	//	CBLAS_TRANSPOSE::CblasNoTrans,
	//	CBLAS_TRANSPOSE::CblasNoTrans,
	//	2,                        // Матрица А M - строк, кол-во изобр в батче
	//	2,                       // Матрица В N - столбцов, кол-во скрытых нейронов 
	//	3,                       // Матрица A N - столбцов, В М - строк, кол-во вх нейронов - размер одного изображения ((w + 1) * h * d) из батча. (+1 - X0)                   
	//	1.0,                           // α - доп коэф умн на результат AB
	//	a,                        // Матрица А - данные
	//	3,                        // Матрица А - размер первого измерения - кол-во столбцов
	//	x,                       // Матрица B - данные
	//	2,                       // Матрица B - размер первого измерения - кол-во столбцов
	//	0.0,                           // β - доп коэф умн на результат C
	//	y,                        // Матрица С - выходные данные
	//	2);                       // Матрица С - размер первого измерения - кол-во столбцов В


	// C = αAB + βC
	// А - матрица вход данных
	// В - матрица весов
	// C - матрица выход данных
	//cblas_sgemm(CBLAS_ORDER::CblasRowMajor,
	//	CBLAS_TRANSPOSE::CblasNoTrans,
	//	CBLAS_TRANSPOSE::CblasNoTrans,
	//	insz.n,                        // Матрица А M - строк, кол-во изобр в батче
	//	kernel_,                       // Матрица В N - столбцов, кол-во скрытых нейронов 
	//	(insz.w + 1) * insz.h * insz.d,// Матрица A N - столбцов, В М - строк, кол-во вх нейронов - размер одного изображения ((w + 1) * h * d) из батча. (+1 - X0)                   
	//	1.0,                           // α - доп коэф умн на результат AB
	//	pDtMem,                        // Матрица А - данные
	//	insz.n,                        // Матрица А - размер первого измерения
	//	weightTns_->getData(),         // Матрица B - данные
	//	(insz.w + 1) * insz.h * insz.d,// Матрица B - размер первого измерения
	//	0.0,                           // β - доп коэф умн на результат C
	//	outTns_->getData(),            // Матрица С - выходные данные
	//	insz.n);                       // Матрица С - размер первого измерения
//
//float a[20] = { 3., 1., 2., 4.,                  //  3   1    2  4
//                0., -1., 4., 5,                  //  0   -1   4
//                0., -1., 4., 5,
//				5., 2., 6., 7.,
//				5., 2., 6., 7.//  5   6    7
//}; // 3 x 4 matrix // 8   9    6
//float x[4] = { -1.,                              //  7   8    9
//                1.,
//                2.,
//                3. };
//
//float y[4] = { 0., 0., 0., 0. };
//
//	// y = a*x + y
//	// a - матрица вход
//	// x - вектор
//	// y - матрица выход
//	cblas_sgemv(CBLAS_ORDER::CblasRowMajor,
//	CBLAS_TRANSPOSE::CblasNoTrans,
//	4,
//	4,
//	1.0,
//	a,
//	5,
//	x,
//	1,
//	0.0,
//	y,
//	1);
//      	return 0;
//	}
//
// float a[40] = { 3., 1., 2., 4.,                  //  3   1    2  4
//	            0., -1., 4., 5,                  //  0   -1   4
//				0., -1., 4., 5,                  //  5   6    7
//				0., -1., 4., 5, 
//				0., -1., 4., 5, 
//				0., -1., 4., 5, 
//				0., -1., 4., 5, 
//				0., -1., 4., 5, 
//				0., -1., 4., 5, 
//				0., -1., 4., 5 
//               }; // 3 x 4 matrix // 8   9    6
//float x[4] = { -1.,   //-6                           //  7   8    9
//                1.,   // 6
//			    2.,   // 12
//				3.};  // 18
//
//float y[4] = { 1., 2., 3., 4.};

//

//size_t ut = 0, kt = 0;
//
//cin >> ut;
//
//
//cin >> kt;
//
//for (size_t m = 0; m < 100; ++m){
//	PROFILE_START
//		for (size_t k = 0; k < 1000; ++k){
//
//			/*valarray<float> vgrad(x, 4);
//			for (size_t i = 0; i < ut; ++i){
//
//				valarray<float> vweight(a + i * kt, kt);
//
//				vweight -= vgrad * float(3.) * float(2.);
//			}*/
//
//			for (size_t i = 0; i < ut; ++i){
//
//				float* vweight = a + i * kt, coef = 3. * 2.;
//
//				for (size_t j = 0; j < kt; ++j)
//					vweight[j] -= x[j] * coef;
//			}
//
//		}
//	PROFILE_END("")
//}


//return 0;
//}